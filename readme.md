# Конвертер валют с точной арифметикой 
## Лабораторная работа № 1
### Описание проекта
В рамках лабораторной работы был реализован консольный конвертер валют, который:

- поддерживает несколько валют (USD, EUR, RUB, BTC, ETH)
- хранит обменные курсы как точные рациональные числа (Rational)
- корректно выполняет операции с дробными суммами без потери точности
- умеет автоматически восстанавливать обратные направления курсов

### Основные возможности
1. Добавление курсов валют — пользователь задаёт отношение между двумя валютами, система хранит его в виде Rational.
2. Двусторонняя синхронизация курсов — автоматически создаётся обратный курс.
3. Конвертация средств между валютами — с поиском пути через граф курсов (используется BFS).
4. Поддержка дробных сумм — ввод и хранение до 8 знаков после запятой.
5. Работа с точными числами — никакого Double, только BigInteger и Rational.
6. Форматирование вывода — суммы красиво выводятся в привычном виде 12.34000000.

### Структура решения
### 1. ```Class Enum Currency```
- Класс хранящий перечисление валют
- Метод fromCode позволяет найти валюту по строковому коду без учёта регистра.
  Используется при вводе пользователем, чтобы преобразовать "usd" → Currency.USD.


### 2. ```data class Rational```
- Хранит рациональные числа в виде дроби: через представление num/znam (числитель/знаменатель)
- Используется для точного хранения обменных курсов; Например, 1 USD = 91.32 RUB хранится как дробь 9132 / 100
- Поддержка арифметических операций: Инвертирование (znam/num)(```invert```); Произведение дробей(```operator fun times```); умножение на BI(BigInteger)(```applyTo```; Нормализация(```normalized```)


### 3. Хранение балансов и сумм (BigInteger + SCALE)
- Все денежные суммы хранятся как целые числа (BigInteger) с масштабом SCALE = 100_000_000 (8 знаков после запятой).
- Это дает высокую точность без округления; простые арифметические операции на целых числах
- При конверсии курсов BigInteger умножается на курсы валют Rational(на дроби)


### 4. Обработка ввода дробных чисел
Чтобы поддерживать суммы вроде 12.34567891, ввод разбивается на целую и дробную части
```
      val amount = try {
                    val parts = amtInput?.split('.') ?: listOf("0")
                    val whole = parts.getOrElse(0) { "0" }.toLong()
                    val fracStr = parts.getOrElse(1) { "0" }.padEnd(8, '0').take(8)
                    val fracBI = BI(fracStr)
                    BI.valueOf(whole) * SCALE + fracBI
                } catch (e: Exception) {
                    println("Неправильная сумма")
                    continue@loop
                }
```
- .padEnd(8, '0') — добавляет недостающие нули, чтобы всегда было ровно 8 знаков после запятой.
- .take(8) — ограничивает длину, чтобы не превысить SCALE.
- Число переводится в BigInteger

### 5. Форматирование вывода
При показе пользователю BI обратно преобразуется:
```
      fun formatAmount(bi: BI): String {
            val whole = bi.divide(SCALE)
            val frac = bi.mod(SCALE).abs().toString().padStart(8, '0')
            return "$whole.$frac"
      }
```
Пример: ```BI = 1234567891 → "12.34567891"```

### 6. Принцип ООП
#### Интерфейс биржи Exchange и его реализация
Для расширяемости кода выделен интерфейс Exchange.
Он описывает поведение обменника, но не задаёт, как именно хранить или вычислять курсы валют.

Это позволяет в будущем, например, заменить консольную реализацию (```ConsoleExchange```) на REST API, работу с базой данных или подключение к реальной бирже — без изменения остального кода.

#### Интерфейс ```Exchange```
```
interface Exchange {
    fun getRate(from: Currency, to: Currency): Rational?
    fun convert(amount: BI, from: Currency, to: Currency): Result<BI>
    fun randomizeRates()
    fun showRates(): String
}
```
- ```getRate(from: Currency, to: Currency)``` возвращает курс обмена между двумя валютам в виде Rational
- ```convert(amount: BI, from: Currency, to: Currency)``` конвертирует amount из валюты `from` в валюту `to`
- ```fun randomizeRates()``` рандомизированно изменяет курс валют 
- ``fun showRates():`` вывод актуальные курсы валют

### Реализация интерфейса - `ConsoleExchange`
- Класс `ConsoleExchange(initRates: Map<Pair<Currency, Currency>, Rational>)` реализует интерфейс `Exchange`
- в него передается список пар захардкоженных изначально
- Валютные пары хранятся в виде графа валют `adj` и `MutableMap rates`((`Currency1`, `Currency2`): курс обмена(`Rational`)))
- Автоматическое добавление обратных направлений (`ensureBothDirections`) в `rates` и `adj`
- Нормализация курса и добавление в обе стороны вынесено в приватный метод `setRate`
- Реализация методов интерфейса:
- `getRate(from: Currency, to: Currency)` проверяет есть ли пара [`from`, `to`] в rates напрямую - если нет прямого курса в `rates`, то:

  метод запускает поиск пути через промежуточные валюты (через BFS графовое представление), перемножая найденные курсы
 
  при каждом шаге перемножаем коэффициенты (Rational) и нормализуем(также сохраняется путь по которому прошли)

  Также пути может не быть - тогда возвращает null
  
  Возможна ситуация при которой можно в зависимости от выбора пути получить разные курсы(аналог ситуации арбитража)


- `override fun convert(amount: BI, from: Currency, to: Currency): Result<BI>`

   1)проверяет что сумма `amount` положительная
   
   2)Получает курс через `GetRate` - в случае если путь существует: применяет его к amount с помощью `Rational.applyTo(amount)`

   3)Возвращает результат как Result.success(res)


- `randomizeRates` изменяет все текущие курсы случайно на ±5%.
  Это добавляет динамику: при каждом вызове котировки изменяются.
  Метод также обновляет обратные курсы (например, если USD→EUR изменился, то EUR→USD пересчитывается автоматически как обратная величина).

  ```
  val multiplier = Rational.of((100 + delta).toLong(), 100) // -5 <= delta <= 5
  val newRate = (v * multiplier).normalized()
  ```

- `showRates()` - возвращает список всех текущих курсов.
  Здесь используется функция `formatRational(r: Rational)` для вывода чисел в привычном виде с 8 знаками после запятой.

  формула для вывода(`r = (num * SCALE)/znam / SCALE`)


### Класс `User(val name: String)`
- Содержит значения всех его балансов во всех в валютах в виде `MutableMap`
- `private val balances: MutableMap<Currency, BI> = mutableMapOf()`
- `deposit(currency: Currency, amount: BI)` - зачисляет на баланс `currency` `amount` единиц валюты - одним обращением к `map`
- `withdraw(currency: Currency, amount: BI): Boolean` - снимает с баланса `currency` `amount` единиц валюты - есть проверка на положительность баланса
- `getBalance(currency: Currency)` возвращает значение баланса в валюте `currency`